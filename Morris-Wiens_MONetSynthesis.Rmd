---
title: "Morris&Wiens_MONetSynthesis"
author: "Kendalynn A. Morris & Nathan J. Wiens"
date: "`r Sys.Date()`"
output:
  html_document: 
    toc: TRUE
    toc_float: TRUE
    toc_depth: 2
   # number_sections: TRUE
  pdf_document: 
    toc: true
    toc_depth: 2
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(
  echo = TRUE,           # Show code in output
  warning = FALSE,       # Hide warning messages
  message = FALSE,       # Hide package loading messages
  fig.width = 6,         # Default figure width
  fig.height = 6         # Default figure height
)
```

# Introduction

This R markdown is designed to be a guide for systematically comparing and integrating MONet soil data with publicly available datasets such as SoilGrids (Hengl et al., 2017) and the Soil Respiration Database (SRDB, Jian et al., 2021). This script executes a series of three comparative and statistical analyses involving 1) soil respiration relative to mean annual precipitation (MAP) and mean annual temperature (MAT), 2) assessments of soil pH within Köppen climatic zones, 3) and the spatial distribution of soil clay content (Table 1). Due to differences in the spatial scale of global data products verses a nationally focused effort such as MONet, the response of soil properties to known drivers will be our metric of comparison (Collier et al., 2018; Shao et al., 2013).

## Prep our R Environment

### Load Packages

General data manipulation: `dplyr` and `tidyr`

Plotting: `ggplot2`, `ggpubr`, `ggpmisc`

Geographic data handling: `sf`, `terra`, `tidyterra`, `raster`, `tiff`

Precipitation and Temperature data: `geodata`

Biome plotting: `devtools`

```{r libraries, results = "hide"}

library(knitr)
library(dplyr)
library(tidyr)
library(ggplot2)
library(ggpubr)
library(ggpmisc)
library(sf)
library(terra)
library(tidyterra)
library(raster)
library(tiff)
library(geodata)
library(devtools)

```
Set up color palette for plotting
```{r graph colors, results = "hide"}

myColors <- c( "#000080","#4040A0","#8080C0", "#D6AA80", "#D98040", "#CC5500")
names(myColors) <- c("MONet_resp", "MONet_pH", "MONet_clay",
                     "comp_clay", "comp_pH", "comp_resp")

```

### Load Pre-processed Data 1 of 2 (this can take a few minutes)

```{r Rs data, warning=FALSE, message=FALSE}

if(!"processed_Rs.RData" %in% list.files("R_data/")){
    print("Generate processed Rs data by sourcing MONetDataPreprocessing.R")
} else {
  
    load("R_data/processed_Rs.RData")

    print("Rs loaded, cheers!")
  }

```

### Load Pre-processed Data 2 of 3 (ditto)

```{r clay data, warning=FALSE, message=FALSE}

if(!"processed_clay.RData" %in% list.files("R_data/")){
  
  print("Generate processed clay data by sourcing MONetDataPreprocessing.R")
 
} else {
  
  load("R_data/processed_clay.RData")

  print("Clay data loaded, cheers!")
}


```
### Load Pre-processed Data 3 of 3 (ditto)

```{r pH data, warning=FALSE, message=FALSE}


if(!"processed_pH.RData" %in% list.files("R_data/")){
  
  print("Generate processed pH data by sourcing MONetDataPreprocessing.R")
 
} else {
  
  load("R_data/processed_pH.RData")

  print("pH data loaded, cheers!")
}

```

# Filter SRDB coordinates within shapefile boundaries
SRDB_coords <- srdb %>%
  dplyr::select(Record_number, Latitude, Longitude) %>%
  na.omit() %>%
  st_as_sf(coords = c("Longitude", "Latitude"), crs = 4326) %>%
  st_transform(target_crs) %>%
  {.[rowSums(st_within(., conus_valid, sparse = FALSE)) > 0, ]}

# Convert coordinates to sf assuming the column names are 'Long' and 'Lat'
monet_rs_coords <- metadata_monetRs %>%
  filter(Site_Code != "PUUM") %>% #Take out one site in HI
  st_as_sf(coords = c("Long", "Lat"), crs = 4326) %>%
  st_transform(target_crs)

# Plotting both Rs datasets

ggplot() +
  geom_sf(data = conus_valid, fill = NA, color = "gray", linetype = "solid") +
  geom_sf(data = SRDB_coords, aes(color = 'SRDB'), size = 1.8, alpha = 0.7) +
  geom_sf(data = monet_rs_coords, aes(color = 'MONet'), size = 2, alpha = 0.7) +
  scale_color_manual(values = c('SRDB' = myColors[[6]], 'MONet' = myColors[[1]])) +
  theme_bw() +
  labs(title = "Soil Respiration Field Sites",
       color = "Data Source") +
  theme(legend.position = "bottom")
```

### Extract Mean Annual Precipitation (MAP) and Mean Annual Temperature (MAT) for sample coordinates

Using the `geodata` package, \~1km\^2 gridded 10 minute precipitation and average temperature data from 1970-2000 is downloaded and and extracted at the MONet and SRDB sample sites. These data are then used to create timeseries of MAP and MAP for each sample location. A selection of sites are plotted for illustration.

```{r Extract MAP and MAT for samples, cache = TRUE, include = FALSE}

# Function to extract climate data: precipitation and temperature
process_climate_data <- function(coords_df, ID_column) {
  coords_extracted <- st_coordinates(coords_df)
  coords_data <- tibble(place = coords_df[[ID_column]], lon = coords_extracted[, "X"], lat = coords_extracted[, "Y"])
  coords_data$ID <- seq_len(nrow(coords_data))

  # WorldClim data extraction
  tavg <- worldclim_global("tavg", "10", "data/worldclim_data/")
  tprec <- worldclim_global("prec", "10", "data/worldclim_data/")

  tavg_extracted <- terra::extract(tavg, coords_data[, c("lon", "lat")])
  tprec_extracted <- terra::extract(tprec, coords_data[, c("lon", "lat")])

  # Calculate MAT and MAP
  coords_data <- coords_data %>%
    mutate(MAT = rowMeans(tavg_extracted[, -1], na.rm = TRUE),
           MAP = rowMeans(tprec_extracted[, -1], na.rm = TRUE) * 12) # Convert to annual precipitation

  # Reshape monthly precipitation data
  monthly_prec <- pivot_longer(tprec_extracted, -ID, names_to = "name", values_to = "precipitation")
  
  # Reshape monthly temperature data
  monthly_temp <- pivot_longer(tavg_extracted, -ID, names_to = "name", values_to = "temperature")

  monthly_prec$month <- as.numeric(gsub("wc2.1_10m_prec_", "", monthly_prec$name))
  monthly_temp$month <- as.numeric(gsub("wc2.1_10m_tavg_", "", monthly_temp$name))

  monthly_joined_prec <- monthly_prec %>% mutate(place = coords_data$place[monthly_prec$ID])
  monthly_joined_temp <- monthly_temp %>% mutate(place = coords_data$place[monthly_temp$ID])

  return(list(monthly_prec = monthly_joined_prec, monthly_temp = monthly_joined_temp, annual = coords_data))
}

# Function to plot MAT/MAP
plot_climatology <- function(monthly_data, title, y_label, value_column) {
  ggplot(monthly_data, aes(month, !!sym(value_column), color = factor(place))) +
    geom_line() +
    labs(title = title, y = y_label, color = "Place") +
    theme_bw() +
    theme(legend.position = "bottom")
}

# Process monet_rs_coords, subset 12 sites and plot
monet_data <- process_climate_data(monet_rs_coords, "Site_Code")
set.seed(42)
sampled_places_monet <- monet_data$annual %>% distinct(place) %>% sample_n(12)
sampled_prec_monet <- monet_data$monthly_prec %>% filter(place %in% sampled_places_monet$place)
sampled_temp_monet <- monet_data$monthly_temp %>% filter(place %in% sampled_places_monet$place)

p_monet_prec <- plot_climatology(sampled_prec_monet, "MAP for MONest subset", "Precipitation", "precipitation")
p_monet_temp <- plot_climatology(sampled_temp_monet, "MAT for MONest subsets", "Air temperature", "temperature")
ggarrange(p_monet_prec, p_monet_temp, ncol = 1, common.legend = TRUE)

# Process SRDB_coords, subset 18 and plot
srdb_data <- process_climate_data(SRDB_coords, "Record_number")
set.seed(42)
sampled_places_srdb <- srdb_data$annual %>% distinct(place) %>% sample_n(12)
sampled_prec_srdb <- srdb_data$monthly_prec %>% filter(place %in% sampled_places_srdb$place)
sampled_temp_srdb <- srdb_data$monthly_temp %>% filter(place %in% sampled_places_srdb$place)

p_srdb_prec <- plot_climatology(sampled_prec_srdb, "MAP for SRDB subset", "Precipitation", "precipitation")
p_srdb_temp <- plot_climatology(sampled_temp_srdb, "MAT for SRDB subset", "Air temperature", "temperature")
ggarrange(p_srdb_prec, p_srdb_temp, ncol = 1, common.legend = TRUE)

```


#### SRDB Conversion

With the calculated MAP and MAT, use a simple linear model to test the influence of MAP and MAT on soil respiration.

Soil respiration is converted from annual soil respiration to mg CO2-C / g soil / day using the following assumptions and parameters:

-   **Bulk density (**$\rho$): 1.33 g/cm³ (mass of soil per unit volume)
-   **Effective soil depth (**$d$): 10 cm as a common depth for soil respiration measurements
-   **Area conversion**: 1 m² = 10,000 cm²

Using the equation:

$$\text{mg C g⁻¹ soil day⁻¹} = \left( \frac{\text{g C m² yr⁻¹}}{1.33 \times 10 \times 10,000} \right) \times \frac{1}{365} \times 1,000$$


#### MONet Rs Index

With the calculated MAP and MAT, use a simple linear model to test the influence of MAP and MAT on annual soil respiration.

```{r tidy MONet Rs data, include = FALSE}

# Select soil respiration from MONet data
monet_rs %>%
  dplyr::select(Sample_Name, respiration_ppm_co2_c,
         respiration_mg_co2_c_g_soil_day_24hour,
         respiration_mg_co2_c_g_soil_day_96hour) -> monet_slim

# Function to separate and add metadata from Sample_Name
extract_metadata <- function(monet_slim) {
  monet_slim %>%
    mutate(
      Site_Code = sapply(strsplit(Sample_Name, "_"), `[`, 3),
      Core_Section = sapply(strsplit(Sample_Name, "_"), `[`, 4)
    )
}

# Extract metadata
monet_rs_metadata <- extract_metadata(monet_slim)

# Integrate this with the annual climate data (MAT, MAP) using Site_Code as key
combined_monet <- monet_rs_metadata %>%
  inner_join(monet_data$annual, by = c("Site_Code" = "place"))

#calculate respiration index and prep for combining with SRDB
monet_rs_index <- combined_monet %>%
  dplyr::select(ID,
                respiration_mg_co2_c_g_soil_day_24hour,
                respiration_mg_co2_c_g_soil_day_96hour,
                Site_Code, Core_Section, MAT, MAP) %>%
  na.omit() %>%
  group_by(ID) %>%
  mutate(weighted_time_respiration = (1/3) * respiration_mg_co2_c_g_soil_day_24hour + (2/3) * respiration_mg_co2_c_g_soil_day_96hour) %>%
  group_by(Site_Code) %>%
  summarise(
    rs_index = sum( case_when(
        Core_Section == "TOP" ~ 0.65 * weighted_time_respiration,
        Core_Section == "BTM" ~ 0.35 * weighted_time_respiration),
      na.rm = TRUE),
    .groups = "drop") %>%
  left_join(combined_monet %>% distinct(Site_Code, MAT, MAP), by = "Site_Code") %>%
  mutate(
    source = "MONet"
  )

```


To represent a single soil respiration data point for each MONet sample core, an index was developed which takes the top and bottom core sample into account as well as the two time points. Given that the majority of biological activity takes place in the top layers of soil, the top sample is weighted greater (65%) than the bottom (35%). After combining top and bottom data for each core, the one and four day respiration rates are given 1/3 and 2/3 weight respectively. 

Index = 0.5 × [ (0.65 × (24 hr Top + 96 hr Top)) + (0.35 × (24 hr Bottom + 96 hr Bottom)) ]

## One to One for Rs

```{r extract SRDB Rs data, include = FALSE}

read_project_mask <- function(raster_path, conus_valid){
  raster <- rast(raster_path)

  prj_raster <- raster%>%
    project(crs(conus_valid))

  prj_raster_mask <- raster::mask(prj_raster, conus_valid)

  return(prj_raster_mask)
}

extract_buffer_srdb <- function(raster, point_data, buffer_size_m){
  sf_use_s2(TRUE)

  buffer_points <- st_buffer(sf_transform_xy(point_data,
                                             source_crs = point_data,
                                             target_crs = point_data), units::set_units(1000, meters))

  sf_use_s2(FALSE)

  extract_buffer_region <- raster::extract(raster, buffer_points,
                                           fun = function(x) list(mean = mean(x/10, na.rm = TRUE),
                                                                  count = length(x[!is.na(x)]),
                                                                  sd = sd(x/10, na.rm = TRUE)),
                                           bind = TRUE)%>%data.frame()

  names(extract_buffer_region)[(ncol(extract_buffer_region)-2):ncol(extract_buffer_region)] <- c("srdb_mean", "srdb_count", "srdb_sd")

  extract_buffer_region[c("srdb_mean", "srdb_count", "srdb_sd")] <- lapply(extract_buffer_region[c("srdb_mean", "srdb_count", "srdb_sd")], as.numeric)

  return(extract_buffer_region)
}

soil_Rh_conus <- read_project_mask("./data/srdb/soil_Rh_mean.tif", conus_valid)
soil_Rh_buffer <-  extract_buffer_srdb(soil_Rh_conus, monet_rs_coords, 1000)


#Plot both Rs datasets
soil_Rh_buffer %>%
  left_join(monet_rs_index, by =  "Site_Code") %>%
  mutate(ymin = srdb_mean - srdb_sd,
         ymax = srdb_mean + srdb_sd)%>%
  ggplot(aes(x = rs_index, y = srdb_mean))+
  geom_point() + lims(x = c(10,80), y = c(10,80)) +
  geom_errorbar(aes(x = rs_index , ymin = ymin, ymax = ymax))+
  geom_abline(intercept = 0, slope = 1, color = "black")+
  stat_smooth(formula = y~x,method = "lm", se = TRUE, level = 0.95)+
  labs(title = "**raw** SRDB Rs vs MONet Rs index",
       x = "mg CO2-C per g soil per d", y = "g CO2-C per m2 per yr")+
  theme_bw()

monet_rs_index$respiration_rate <- monet_rs_index$rs_index

soil_Rh_buffer %>%
  left_join(monet_rs_index, by =  "Site_Code") %>%
  na.omit() %>%
  dplyr::select(-"respiration_rate") %>%
  mutate(respiration_rate = srdb_mean * 2.06e-05) %>%
  dplyr::select("Site_Code", "respiration_rate",
         "srdb_count", "srdb_sd", "MAT", "MAP") %>%
  mutate(source = "SRDB") -> srdb_ready2_join

bind_rows(monet_rs_index, srdb_ready2_join) -> rs_combined

# Create summary table
summary_table <- rs_combined %>%
  group_by(source) %>%
  summarize(
    min_respiration_rate = min(respiration_rate, na.rm = TRUE),
    max_respiration_rate = max(respiration_rate, na.rm = TRUE),
    mean_respiration_rate = mean(respiration_rate, na.rm = TRUE)
  )

# Display the table using kable
summary_table %>%
  kable(
    caption = "Summary of Respiration Rate by Source",
    col.names = c("Source", "Min Respiration Rate", "Max Respiration Rate", "Mean Respiration Rate"),
    format = "html"
  )

```



## Impact of MAP and MAT on Soil Respiration by source

```{r Rs Analysis, fig.dim=c(6,4), fig.align='center'}

cd4m <- rs_combined %>%
  group_by(source) %>%
  mutate(respiration_z = (respiration_rate - mean(respiration_rate)) / sd(respiration_rate)) %>%
  ungroup()

### Step 1: Linear Model of Z-Scaled Data
model1 <- lm(respiration_z ~ source + MAT + MAP, data = cd4m)
summary(model1)

### Step 2: Reshape Data and Facetted Plot
cd4m %>%
  pivot_longer(cols = c(MAT, MAP), names_to = "climate_parameter", values_to = "climate_value") %>%
  ggplot(aes(x = climate_value, y = respiration_z)) +
  geom_point(aes(color = source), alpha = 0.7, size = 3) + # Scatter plot
  geom_smooth(method = "lm", se = FALSE, aes(color = source)) + # Regression line
  facet_wrap(climate_parameter ~ ., scales = "free_x") + # Facet by source and climate_parameter
  stat_poly_eq(
    aes(label = paste(..eq.label.., ..rr.label.., sep = "~~~"),
        group = source,
        color = source),
    formula = y ~ x,
    parse = TRUE,
    size = 3
  ) + # Regression equation and R²
  labs(
    title = "Rs vs Climate by Data Source",
    x = "Climate Parameter",
    y = "Z-score Respiration Rate (mg C per g soil per day)"
  ) +
  scale_color_manual(values = c("SRDB" = "#0072B2", "MONet" = "#D55E00")) +
  theme_minimal()

### Step 3: Original, non-Z-scaled data
model2 <- lm(respiration_rate ~ source + MAT + MAP, data = cd4m)
summary(model2)

cd4m %>%
  pivot_longer(cols = c(MAT, MAP), names_to = "climate_parameter", values_to = "climate_value") %>%
  ggplot(aes(x = climate_value, y = respiration_rate)) +
  geom_point(aes(color = source), alpha = 0.7, size = 3) + # Scatter plot
  geom_smooth(method = "lm", se = FALSE, aes(color = source)) + # Regression line
  facet_wrap(source ~ climate_parameter, scales = "free") + # Facet by source and climate_parameter
  stat_poly_eq(
    aes(label = paste(..eq.label.., ..rr.label.., sep = "~~~"),
        group = source,
        color = source),
    formula = y ~ x,
    parse = TRUE,
    size = 3
  ) + # Regression equation and R²
  labs(
    title = "Rs vs Climate by Data Source",
    x = "Climate Parameter",
    y = "NOTE VARIABLE SCALE \n Respiration Rate (mg C per g soil per day)"
  ) +
  scale_color_manual(values = c("SRDB" = "#0072B2", "MONet" = "#D55E00")) +
  theme_minimal()

rm("p_monet_prec", "p_monet_temp", "p_srdb_prec", "p_srdb_temp")
```

# MONet vs SoilGrids density distributions

SoilGrids values are extracted at MONet sampling coordinates to enable direct point-to-point comparisons of pH and clay content of both datasets. The distribution of these points are compared to evaluated ability of direct geographic comparisons.

![Density distribution of pH data.](graphs/pH_hist.png)
![Density distribution of clay data.](graphs/clay_hist.png)

# 2. pH assessemnt within Koppen Climate Zones

## Extract Köppen Climate Zones for MONet data

This section loads a shapefile of the Köppen Climate Zones of North America, filters the climate zone shapefile to CONUS, and extracts the climate region for each data site location in MONet and 1000 soils. All spatial data are transformed into the target CRS to ensure accuracy.

If your data directory is missing the file below, download and move into the "data" folder.

[North American Köppen Climate Zones](https://www.cec.org/north-american-environmental-atlas/climate-zones-of-north-america)

### Load in North American Climate Zones

```{r load climate, warning=FALSE, message=FALSE, cache = TRUE, fig.dim=c(6,4), fig.align='center'}

# Load the shapefile as an `sf` object
climate_zones_sf <- st_read("data/shapefiles/na_climatezones_shapefile/climatezones_shapefile/NA_ClimateZones/data/North_America_Climate_Zones.shp")%>%
  st_transform(crs(conus_valid))

# Create a mapping table for the 3 letter climate zone code to the full name
# climate_zone_mapping <- climate_zones_sf%>%
#   distinct(Code, Climate)

# Find intersection of climate zones and CONUS
climate_zones_conus_sf <- climate_zones_sf%>%
  st_intersection(st_union(conus_valid))

# Define the target CRS from the shapefile
target_crs <- st_crs(conus_valid)

ggplot() +
  geom_sf(data = climate_zones_conus_sf, aes(fill = Climate), color = "darkslategrey", alpha = 1) +
  geom_sf(data = conus_valid, color = "black", alpha = 0.3)+
  geom_sf(data = monet_rs_coords, size = 2.5, color = "white") +
  geom_sf(data = monet_rs_coords, size = 2, color = "#000080") +
  theme_bw()+
  labs(title = "CONUS Köppen Climate Zones of North America")+
  scale_color_discrete(drop=T)+
  theme(legend.position = "none")

```

The following MONet sites were excluded from the following analysis since there was only one sample available for the climate zone:

-   Anza Borrego Desert State (Hot Desert Climate)\
-   Santa Rita Experimental Range NEON (Hot Semi-Arid Climate)\
-   Northern Great Plains Research Laboratory NEON (Humid Continental Hot Summers with Dry Winters)\
-   Dakota Coteau Field Site NEON (Humid Continental Mild Summer with Dry Winters)\
-   Peterson Farm (Temperate Oceanic Climate)\
-   Beaver Creek, Washington (Warm-Summer Mediterranean Climate)

For each region with more than one MONet site, 1,000 observations of Soilgrids data were randomly sampled to illustrate the distribution of pH and clay content in each climate zone.

## Plot distribution of pH in each region

Some text about pH by region!  

```{r SG functions, include = FALSE}

sg_random_sample <- function(MONet_sg_top, sample_sizes_sg_top, seeds){
  
  MONet_data <- MONet_sg_top %>%
    filter(source == "MONet")
  
  for(seed in seeds){
    set.seed(seed)
    for(zone in unique(sample_sizes_sg_top$Climate)){
      
      n_samples <- sample_sizes_sg_top$MONet[sample_sizes_sg_top$Climate == zone]
    
      sampled_sg_zone <- MONet_sg_top%>%
        as.data.frame()%>%
        filter(Climate == zone, source != "MONet")%>%
        slice_sample(n = n_samples)%>%
        mutate(source = paste0("soilgrids_sample_", which(seed == seeds)))
      
      MONet_data <- bind_rows(MONet_data, sampled_sg_zone)
    }
  }
    return(MONet_data)
}

process_soil_data <- function(type, section, MONet_df, sg_df, climate_mapping_df, sg_column_name) {
  # Process MONet data
  MONet_data <- MONet_df %>%
    left_join(climate_mapping_df, by = c("Climate", "Code")) %>%
    filter(core_section == section) %>%
    dplyr::select(Climate, !!type) %>%
    mutate(source = "MONet")

  # Process SoilGrids data
  sg_data <- sg_df %>%
    left_join(climate_mapping_df, by = c("zone" = "Code")) %>%
    filter(Climate %in% unique(MONet_data$Climate)) %>%
    rename(!!type := sg_column_name) %>%
    dplyr::select(Climate, !!type) %>%
    mutate(source = "soilGrids",
           !!type := !!sym(type) / 10) # convert units

  # Combine MONet and SoilGrids data
  combined_data <- bind_rows(MONet_data, sg_data)
  return(combined_data)
}

```
 
Some text about pH and random sampling from Soil Grids.   
 
![Random sampling of SoilGrids vs MONet pH.](graphs/pH_randomsample.png)

In general, MONet data does moderately well at capturing the distribution of pH seen in SoilGrids.  

![One to One SoilGrids vs MONet pH.](graphs/pH_OneToOne.png)

```{r}
sg_pH_buffer%>%
  mutate(ymin = sg_mean - sg_sd,
         ymax = sg_mean + sg_sd)%>%
  ggplot(aes(x = pH, y = sg_mean, color = core_section, fill = core_section))+
  geom_point()+
  geom_errorbar(aes(x = pH, ymin = ymin, ymax = ymax))+
  geom_abline(intercept = 0, slope = 1, color = "black")+
  stat_smooth(formula = y~x,method = "lm", se = TRUE, level = 0.95)+
  labs(title = "pH Soilgrids vs MONet",
       x = "MONet", y = "Soilgrids")+
  theme_bw()
  ```

# 3. Spatial Comparison of Clay Content

## MONet datapoints not in soilgrids

This analysis identified 6 MONet sample sites in locations with incomplete data in the soil grids dataset. Even though these locations are considered as urban sites and not recorded in soil grids, having data on the soil biogeochemistry composition can offer insights into soil health and processes in urban environments. The 6 locations were made up of 3 site in Baltimore, MD, 2 in Philadelphia, PA, and 1 in College Park, MD:

-   Northwest Baltimore Base of Slope Adelphi, MD
-   Northwest Baltimore Mid Slope Adelphi, MD
-   Northwest Baltimore Top of Slope Adelphi, MD
-   Urban CZO (College Park, MD)
-   Winters Lane Lower Soil Pit (Philadelphia, PA)
-   Winters Lane Upper Soil Pit (Philadelphia, PA)

```{r MONet not in Soilgrids, fig.dim=c(6,5), fig.align='center', cache = TRUE}

monet_clay_missing <- rbind(sg_clay_monet_top_values%>%
                              filter(is.na(crop_roi_igh_clay_0.5cm))%>%
                              dplyr::select(Clay_percent, source, core_section, sample),
                            sg_clay_monet_btm_values%>%
                              filter(is.na(crop_roi_igh_clay_15.30cm))%>%
                              dplyr::select(Clay_percent, source, core_section, sample))%>%
  mutate(missing = TRUE)
  

missing_clay <- clay_loc_sf_top%>%
  left_join(monet_clay_missing, by = c("core_section", "Clay_percent", "source", "sample"))%>%
  filter(missing == TRUE)%>%
    separate(sample, into = c("prj", "Site_Code"))%>%
    left_join(metadata_monetRs, by = c("Site_Code"))
  

sg_clay_conus_top <- terra::rast("R_data/sg_clay_conus_top.tif") 

crop_extent <- terra::ext(-78, -74.5, 38.25, 40.5) # Define crop extent
sg_clay_top_prj_final <- terra::crop(sg_clay_conus_top, crop_extent)  # Crop raster to extent
#TODO is reprojection necessary 
#sg_clay_top_prj <- terra::project(sg_clay_top_prj_final, target_crs)

#To DO: replace/overlay site codes with sample counts
ggplot()+
  tidyterra::geom_spatraster(data = sg_clay_top_prj_final)+
  geom_sf(data = conus_valid, color = "grey", alpha = 0.5)+
  geom_sf(data = missing_clay, color = "black", size = 3.5)+
  geom_sf(data = missing_clay, aes(color=Site_Code), size = 3)+
  coord_sf(xlim = c(-78,-74),ylim = c(38,41))+
  theme_bw()+
  scale_fill_gradient(low = 'white', high = 'blue', na.value=NA)+
  labs(title = "MONet data points without Soilgrids data")

```

## Clay 1:1

Some text about clay content of soil.  

```{r future home of clay 1:1 plot}

sg_clay_buffer%>%
  mutate(ymin = sg_mean - sg_sd,
         ymax = sg_mean + sg_sd)%>%
  ggplot(aes(x = Clay_percent, y = sg_mean, color = core_section, fill = core_section))+
  geom_point()+
  #geom_path()
  geom_errorbar(aes(x = Clay_percent, ymin = ymin, ymax = ymax))+
  geom_abline(intercept = 0, slope = 1, color = "black")+
  stat_smooth(formula = y~x,method = "lm", se = TRUE, level = 0.95)+
  labs(title = "Clay Percent Soilgrids vs MONet",
       x = "MONet", y = "Soilgrids")+
  theme_bw()

#likely will be read in as an image

```

## Clay Content Violins

Possibly remove?  

```{r violin plot data, echo=FALSE, warning=FALSE, message=FALSE, cache = TRUE}
# Boxplots of MONet and Soilgrids comparison by climate region

# load("R_data/violin_data.Rdata")

```

```{r clay violin plots, fig.dim=c(10,10), echo=FALSE, warning=FALSE, message=FALSE, cache = TRUE}

generate_violin_plots <- function(plot_data, value_col, source_mapping, title, x_label){
  plot_data%>%
    mutate(Experiment = as.factor(if_else(source == "MONet", "MONet_clay", "comp_clay")))%>%
    filter(!is.na(axis_label))%>%
    ggplot(aes(x = !!sym(value_col), y = axis_label, fill = Experiment, color = Experiment)) +
      geom_violin(alpha = 0.7, 
                  position = position_dodge(width = 0.8),
                  scale = "width") +  # Equal widths regardless of sample size
      geom_boxplot(fill = NA,
                   position = position_dodge(width = 0.8),
                   outlier.shape = NA)+
      theme_bw()+
   scale_fill_manual(name = "Experiment", values = myColors, labels = source_mapping)+
   scale_color_manual(name = "Experiment", values = myColors, labels = source_mapping)+
   labs(
     title = title,
     x = x_label,
     y = "Climate Zone"
   )+
  scale_y_discrete(labels = label_wrap_gen(30))
}

generate_violin_plots(plot_data = plot_clay_top,
                      value_col = "Clay_percent", 
                      source_mapping = c("comp_clay" = "Soilgrids", "MONet_clay" = "MONet"),
                      title = "MONet and Soilgrids Clay Content by Climate Zone (Top sample)", 
                      x_label = "Clay Content (%)")

generate_violin_plots(plot_data = plot_clay_btm,
                      value_col = "Clay_percent", 
                      source_mapping = c("comp_clay" = "Soilgrids", "MONet_clay" = "MONet"),
                      title = "MONet and Soilgrids Clay Content by Climate Zone (Bottom sample)", 
                      x_label = "Clay Content (%)")

```

## Overlay Map

```{r spatial comparison, fig.dim = c(8,8), fig.align='center', echo=FALSE, warning=FALSE, message=FALSE, cache = TRUE, cache.lazy = FALSE}


ggplot()+
  tidyterra::geom_spatraster(data = sg_clay_conus_top) +
  geom_sf(data = conus_valid, color = "black", alpha = 0.3)+
  geom_sf(data = clay_loc_sf_top, aes(fill = Clay_percent), colour = "black", size =3)+
  geom_sf(data = clay_loc_sf_top, aes(color = Clay_percent), size =2)+
  theme_bw()+
  scale_fill_gradient(low = 'white', high = 'blue', na.value=NA, limits = c(0,85))+
  scale_color_gradient(low = 'white', high = 'blue', na.value=NA, limits = c(0,85), guide = "none")+
  labs(
    title = "Spatial Comparison of MONet Clay Content to Soilgrids (Top sample)",
    fill = "% Clay")


```

![Spatial Comparison of MONet and GCAM Clay.](graphs/MONet_GCAM_plot.png)

## GCAM Clay Comparisons

```{r future home of GCAM clay figure}

MONet_GCAM_clay%>%
  mutate(ymin = gcam_q1_value,
         ymax = gcam_q3_value)%>%
  ggplot(aes(x = Clay_percent_mean , y = gcam_average , color = glu_nm, shape = core_section))+
  geom_point()+
  geom_errorbar(aes(x = Clay_percent_mean , ymin = ymin, ymax = ymax ), alpha = 0.5)+
  geom_errorbar(aes(x = gcam_average , xmin = Clay_percent_mean - monet_sd, xmax = Clay_percent_mean + monet_sd), alpha = 0.5)+
  geom_abline(intercept = 0, slope = 1, color = "black")+
  stat_smooth(formula = y~x,method = "lm", se = TRUE, level = 0.95)+
  labs(title = "Clay Content GCAM vs MONet by Basin",
       x = "MONet", y = "GCAM")+
  theme_bw()

```

